# 《区块链+边缘计算技术白皮书2020》

## 区块链特性

分布式是技术基础，防篡改保证了数据的稳定性和可靠性，透明性多方共识保证了数据的可验证和可信性，去中心化信任是区块链技术特征的自然结果，确保了价值能够高效、透明、安全、可信地存储和传递。

## 区块链应用领域
区块链在更多产业领域得到应用：数字金融，数字经济，数字身份，产业协同，社会民生，智慧城市，智慧政务

## 边缘计算定义
边缘计算在靠近用户的地方提供计算、存储、网络等基础设施，通过在该基础设施上部署和运行应用，为用户就近提供边缘云服务。
相较传统云计算的集中部署，边缘计算解决了通信时延长、汇聚流量大问题，为低时延和高带宽的业务提供了更好支持。

## 新型云架构计算
边缘云+中心云

## 区块链为边缘计算提供信任
5G+行动为单个垂直行业提供通信和信息服务，边缘计算中引入区块链服务能够实现不同产业之间的协同，为垂直行业提供中立、可信、易用的“信息+信任”平台

## MEC（multi-access edge computing）多接入边缘计算

## 区块链+MEC部署三种模式
on-MEC 区块链部署在MEC资源池内
off-MEC 区块链部署在MEC资源池外
hybrid-MEC 混合部署

## 区块链+边缘计算的技术挑战
1.技术成熟度低
2.资源开销尚待降低
3.应用场景尚待扩展
4.安全威胁有待解决：传统安全威胁（DDoS，后门），区块链特有安全威胁（共识算法攻击、女巫攻击、分叉）

## 女巫攻击

网络中的少数节点控制多个虚假身份，利用身份控制网络中大量正常节点的攻击方式

# 《区块链安全-详谈共识攻击》
## 记账权力
比特币区块链通过竞争记账的方式解决去中心化的记账系统的一致性问题, 即以每个节点的计算能力即“算力”来竞争记账权的机制。
区块链的共识过程也就是我们所说的选择一个leader的过程，并且有这个领导人来进行新的区块的发布工作

## 区块的数学模型表示
我们将一个区块表示为包含三元组的数据 包 B = (h'，tx，nonce)，其中h' 是前一个区块的哈希， tx 是区块中所包含的交易记录，nonce 是一个 32 比特的整数
## pow攻击（proof of work，工作量证明）
### 双花攻击
双重花费
### 51%攻击
### 自私挖矿
矿工维护一个公开区块链，一个私密区块链。挖到区块后，首先添加到本地的私密区块链，而不是广播给其他矿工。此时，由于矿工已知上一个区块的值，可以先人一步进入下一个区块的计算。即使当前区块被人提前发了出来，也可将自己挖出的区块发到全网（公平竞争，被承认概率1/2）
只对pow有用
## pos（proof of stake，股权证明）
共识算法根据参与者持有股权比例，选出下一个leader。换句话说，持有资产越多的人，计算难度越低
优点：节约选出leader时需要的计算资源；贴近金融，有通胀情况产生
缺点：贫富不均；仍然需要哈希计算，故仍然存在计算资源浪费
伪代码
```
系统输入：tx、nonce、D

Pos过程：
1：nonce = 1（初值）
2：coins←accountBalance
3：age←currentTime-lashTransactionTime //币龄
4：while(H(nonce，tx，h') > = coins * age * D):
5：          nonce++
6：Broadcast( < nonce，tx，h' > )//广播计算的值
7：end
```
## dpos（delegated proof of stake，委托股权证明）
### 三种类型用户
**见证人**如同矿工，通过处理交易和维护区块链来获得报酬。而**代表**可以发起更新请求，但是他们并没有报酬。**工人**可以提出自己下一步的项目想法，如果此项目获得了大部分人的投票支持，那么他们会从中获得收益。
### 见证人选举
只有拥有被选举权的永久节点才能够被选举，最终只有前N名见证人可以被选举出来。这N个人都要获得50%以上的票数才能够顺利当选，除此之外，这个名单会按照固定的时间间隔进行重新选举。
### 见证人出快
见证人每生产一个块，都会获得报酬，他们的薪酬水平由其获得的投票决定。如果见证人没有生产区块，他们便没有收入，并且还有可能被 投票失去见证人的身份。
见证人生产区块时，每 2 s 生产一个区块，如果见 证人没有在规定的时间生产块，那么这个见证人将会
每2s需要产生一个区块，如果超过了规定的时间，那么当前见证人就会失去生产权利而转交给下一个人。
网络中所有的用户均有责任监控区块链生成的过程，并且同意需要选择分叉最长的那个链进行追加。
## 确定性共识算法面临的攻击
### 重放攻击
重放广播的区块，修改其中的交易部分
应对方法：
1.对于UTXO模型，我们需要对收到的交易检查其Hash是否存在。
2.对于Balance模型，我们需要防止随机数NONCE用以防止重放攻击。
3.时间戳
### 权力压迫攻击
攻击者在获得记账权的时候利用手中的部分权利实施一些操作让系统的随机数产生偏移用以增加自己下一次获得记账权力的可能性
1.验证者通过一些参数的组合找到一些特殊参数用以增加自己被选择的可能性。
2.利用对当前区块的控制力来影响下一个区块。

## 拜占庭将军问题
如何让众多完全平等的节点针对某一状态达成共识
### 拜占庭容错（Byzantine fault tolerance，BFT）
```
假设分布式节点存在3f+1个，最大恶意节点的容忍数量为f个，算法流程如下
1.客户端向主节点请求服务
2.主节点广播给副节点
3.副节点执行内容并反馈
4.客户端收到f+1个相同答案的数据
```
### 授权拜占庭容错（Delegated BFT, DBFT）
```
1获取议员名单：这种共识机制与议会制度十分相似，而每个区块的生成都是在议长的主持下由议会成员共同协商而生成的。
2确定议长：确定议长的算法是当前区块高度+1 再减去当前的视图编号，结果mod上当前的议员人数，结果就是议长的下标。
3议长发起共识：议长在更新完视图编号后，如果当前时间距离上次写入新区块的时间超过了预定的每轮共识的间隔时间（15s）则立即开始新一轮的共识，否则等到间隔时间后再发起共识。
4议员参与共识：当议长发起共识后会广播给议员节点，此时议员收到消息后对消息进行公钥验证，之后进行共识。
5视图更新：一个视图生存周期完成的时候，如果共识还没有被达成，则议员会发送广播请求进入下一个视图周期并重新选择议长，当请求更新视图的请求大于议员数量的2/3的时候，全网达成共识进入下一个视图周期重新开始共识过程。
```
与BFT相比
```
1将C/S架构的请求响应模式，改进为适合P2P网络的对等节点模式
2将静态的共识参与节点改进为可动态进入、退出的动态共识参与节点
3为共识参与节点的产生设计了一套基于持有权益比例的投票机制，通过投票决定共识参与节点（记账节点）
4在区块链中引入数字证书，解决了投票中对记账节点真实身份的认证问题
```
### DBFT安全隐患
主要由于时延产生

## 日蚀攻击
条件：P2P网络；40%算力
攻击原理未看懂
```

```
## 区块链贿赂攻击（Bribery attacks）
社会工程学，与具体技术无关
## 瑞波共识算法
三类节点：活跃信任节点、不活跃信任节点、验证节点
流程：①系统中客户端进行交易、②验证节点接收并存储交易、③信任节点发送提议于验证节点、④验证节点验证列表、⑤达成账本共识并关闭账本
安全性：BFT能力为$(n-1)/5$，即容许20%的节点出现拜占庭错误
## POET-消逝时间量证明
原理：以CPU为基本单位，随机产生一些延时，谁的延时最低，谁获得记账权（类似彩票算法）

## 长程攻击（Long-Range Attacks）

原理：攻击者创造一条从创世区块开始的长区块链分治，试图替换当前的合法主链。又称替换历史攻击或历史覆写攻击。

对象：针对PoS。由于PoS依据是无代价模拟的模式，因此几乎不需要消耗算力就可以创建一条从创世区块开始的长分支链。

具体攻击方法：简单攻击，变节攻击，权益流损，浪子漏洞，自杀漏洞

# 《一文读懂区块链的共识机制》

## PoW和PoS

PoW和PoS为抗女巫攻击的机制，PoW为算力投入，PoS为代币投入。

## 中本聪共识

当你看到提议的区块拥有最多工作量证明，就接受它

## 实用拜占庭容错算法 PBFT

让一组参与者进行多轮投票，知道一定比例的投票者达成共识

## 基于PoS的机制

选择某人提议区块，将区块发给其他参与者，由其他参与者进行投票

<<<<<<< HEAD
# 《精通比特币》

## 第4章 密钥、地址、钱包

### 4.1 基于椭圆曲线的公私钥

$$K=k*G$$

其中k是私钥，G是被称为生成点的常数点，K是公钥。通过k求得K容易；通过K反求k困难。

### 4.2 密钥格式

#### 4.2.1 私钥

raw：原始

hex：16进制

WIF：Base58Check

WIF-compressed：在WIF的基础上添加前缀0x01

#### 4.2.2 公钥

非压缩格式：点(x,y)

压缩格式：1）只存储x坐标，因为y欧标可以解方程得到；2）以02或03位前缀，表示y的正负值

#### 4.2.3 压缩格式的私钥

定义：只能生成压缩公钥的私钥

#### 4.2.4 加密私钥（BIP-38）

## 第5章 钱包

钱包里没有比特币，只有密钥

### 5.1 钱包分类

#### 5.1.1 非确定性钱包

每个密钥随机生成，彼此无关

缺点：难以管理，难以备份，容易丢失

#### 5.1.2 确定性（基于种子）钱包

种子足够恢复所有私钥，允许在不同钱包之间迁移所有用户密钥

#### 5.1.3 分层确定性钱包（HD Wallets（BIP-32/BIP-44））

种子以树状结构生成一系列密钥

树状结构可用来表达福建的组织意义；用户可以创建一系列公钥，而不需要访问对应私钥

#### 5.1.4 种子和助记词（BIP 39）

从一系列英文单词创建种子。

如今主流标准。

### 5.2 助记词技术细节

创建助记词

```
1、创建一个128到256位的随机序列（熵）。
2、提取SHA256哈希的前（熵长/ 32的比值）位，创造随机序列的校验和。
3、将校验和添加到随机序列的末尾。
4、将序列拆分为11位长度的多个段。
5、将每个11位值映射为有2048个单词的预定义字典中的一个单词。
6、生成的有顺序的单词组就是助记码。
```

从助记词生成种子

```
7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记词。
8、PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“mnemonic”与可选的用户提供的密码口令一起组成。
9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记词和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。
```

#### 密码延伸函数

参数：助记词+盐

#### 可选密码口令

定义：盐的一部分

优点：

1.助记词外的二重保护

2.胁迫钱包：把选定的密码口令指向小额钱包，分散攻击者注意力

缺点：

1.钱包所有者无行为能力或死亡，密码丢失，则资金也会丢失

2.若口令与种子备份在相同的地方，则失去第二重保护的目的

### 5.3 从种子创造HD钱包

#### 5.3.1 子私钥的衍生

子密钥衍生函数需要：父私钥或父公钥+链码+索引号

子私钥用处：制作公钥和比特币地址；对地址签署交易和支付花费

#### 5.3.2 子公钥的衍生

方法1：子私钥

方法2：父公钥

#### 5.3.3 强化子私钥

原本问题：xpub包含链码，若子私钥泄露，则可以衍生其他子私钥，或者推断父私钥。

强化衍生：使用父私钥推导子链码

## 第6章 交易

### 6.3 交易的输入输出

#### UTXO

unspent transaction outputs 未花费的交易输出

比特币交易中不可分割的单位

#### 交易输出

一定量的比特币

确定花费输出所需条件的加密难题。此加密难题又称锁定脚本（locking script）、见证脚本（witness script）或脚本公钥（scriptPubKey）

#### 交易传输

序列化的数据传输：数据结构内部表示转换为一次可以发送一个字节的格式（也称字节流）

反序列化or交易解析：将字节流转换为库的内部表示数据结构的过程

#### 交易输入

标识哪个UTXO被消费，并通过解锁脚本提供所有权证明

组成：

1. 交易ID
2. 指向UTXO的指针（vout）：引用交易哈希和输出索引
3. 解锁脚本（scriptSig）
4. 序列号

#### 交易费

输出比特币-输入比特币

### 6.4 比特币交易脚本和脚本语言

#### 特性

图灵不完备性：复杂性有限，执行时间可预见

无状态验证：执行脚本所需的所有信息都包含在脚本中

#### 算法

逆波兰式

#### 流程

每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次执行解锁脚本和锁定脚本。 如果解锁脚本满足锁定脚本的条件，则输入有效。 所有输入都是作为交易总体验证的一部分独立验证的。

例子：2 3 OP_ADD 5 OP_EQUAL

其中 2 3 OP_ADD 为锁定脚本， 5 OP_EQUAL为验证脚本

### P2PKH标准

锁定脚本：OP_DUP OP_HASH160 <Cafe Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG

解锁脚本：<Cafe Signature> <Cafe Public Key>

## 第7章 高级交易和脚本

### 7.2 多重签名

#### 一般形式

M <Public Key 1> <Public Key 2> ... <Public Key N> N CHECKMULTISIG

M为花费输出所需签名的数量底线，N是列出的公钥的总数

#### CHECKMULTISIG中的BUG

会弹出额外值，需要在签名前添加一个无效签名

```
0 <Signature B> <Signature C> 2 <Public Key A> <Public Key B> <Public Key C> 3 CHECKMULTISIG
```

### 7.3 P2SH（pay to script hash）

问题来源：脚本太长太复杂，难以使用

解决方法：锁定脚本原本内容放置到兑换脚本（redeem script）中，锁定脚本由兑换脚本的Hash值替换

### 7.4 数据记录输出（RETURN操作符）

问题来源：区块链用于存储非交易数据，UTXO集膨胀

解决方法：RETURN操作符允许开发者在交易输出上增加80字节的非支付数据，此类数据为可验证不可消费型数据，无需存储于UTXO集

### 7.5 时间锁（略过）

nLocktime：交易级

CHECKLOCKTIMEVERIFY：UTXO级

CHECKSEQUENCEVERIFY：UTXO级

### 7.6 流程控制脚本

逆波兰式表达，条件语句在IF操作码前

### 7.8 隔离见证（没看懂）

#### 用处

将见证数据从解锁脚本（scriptSig）字段移动到伴随交易的独立的见证数据结构中

#### 好处

交易延展性：交易哈希不能被交易创建者之外任何人修改

脚本版本控制

网络和存储扩展

签名验证优化

离线签名改进

#### 软分叉

允许未升级软件继续使用解锁脚本

### 隔离验证（参考其他资料）

#### 定义

将见证数据从交易信息中抽离，单独存放。交易信息中不存放解锁脚本，改为存放witness（见证数据）

#### 用处

区块链扩容：原解锁脚本的位置用于存放数据，增加了区块大小

#### 好处

解决交易延展性问题

为闪电网络铺路：增加区块大小无法从根本上解决比特币扩容。闪电网络在比特币基础上，构建第二层网络（略...）

## 第8章 比特币网络

### 8.1 网络架构

点对点网络

Stratum：用于挖矿、轻量级或移动端比特币钱包

### 8.2 节点类型

全节点包含功能：钱包W(wallet)、矿工M(miner)，完整的区块链数据库B(full blockchain)，网络路由N(network routing node)

SPV节点：simplified payment verification 简单支付验证

```
比特币参考客户端 reference client (bitcoin core)：
	W+M+B+N
全区块链节点 full block chain node
	B+N
独立矿工 solo miner
	M+B+N
轻量级钱包 lightweight(SPV) wallet
	W+N
池协议服务器 pool protocol servers
	P(pool server 池服务器)+S(stratum server)
挖矿节点 mining nodes
	M+S 或者 M+P
轻量级Stratum钱包 lightweight(SPV) stratum wallet
	W+S
```



### 8.3 扩展比特币网络

bitcoin core比特币参考客户端：监听节点

挖矿节点：solo miners和pool miners

### 8.4 比特币传输网络

是一种尝试最小化矿工之间区块传输延迟的网络

### 8.5 网络发现

#### 步骤

步骤1：本地节点发送给对等节点版本消息nVersion

步骤2：若对等节点兼容，则本地节点将受到verack，建立连接

步骤3、4：对等节点重复本地节点行为，实现握手

#### 如何找到对等节点

DNS种子查询DNS：DNS种子是提供比特币节点IP地址列表的DNS服务器，其中一些种子提供了稳定的比特币侦听节点的IP地址静态列表

新节点发送一条包含自身IP地址的addr消息给其相邻节点。相邻节点再将此条addr消息依次转发给它们各自的相邻节点，从而保证新节点被其他节点知道、更好连接。另外，新接入的节点可以向它的相邻节点发送getaddr消息，要求它们返回其已知对等节点的IP地址列表。通过这种方式，节点可以找到需连接到的对等节点，并向网络发布它的消息以便其他节点查找。图8-5描述了这种地址发现协议。

### 8.6 全节点

需要超过100GB的持久存储

当前最常用的是bitcoin core客户端，被称为“Satoshi客户端”

### 8.8 SPV节点

#### 与全节点区别

全节点通过高度验证，SPV节点通过深度验证。

SPV节点只下载区块头，大小只有完整区块链的1/1000

栗子：一个全节点要检查第300,000号区块中的某个交易，它会把从该区块开始一直回溯到创世区块的300,000个区块全部都链接起来，并建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性。SPV节点则不能验证UTXO是否还未被支付。相反地，SPV节点会在该交易信息和它所在区块之间用merkle路径建立一条链接。然后SPV节点一直等待，直到序号从300,001到300,006的六个区块堆叠在该交易所在的区块之上，并通过确立交易的深度是在第300,006区块~第300,001区块之下来验证交易的有效性。事实上，如果网络中的其他节点都接受了第300,000区块，并通过足够的工作在该块之上又生成了6个区块，就是代理其证明该交易不是双重支付。

#### 缺点

不能验证交易不存在，容易受到网络分区工具或sybil攻击

### 8.9 布隆过滤器

#### 定义

基于概率的过滤方法，允许用户无需精确指定来描述特定模式

#### 优点

保护用户隐私

#### 特点

隐私提供越多，搜索结果越准确

#### 如何工作

参考8.9.1，通过M个哈希函数，将模式映射到N个可变长度数字数组上，将被映射到的数字置为1。

查询某个模式是否存在，通过M个哈希函数，查询映射到的数字结果是否全为1.

### 8.10 SPV节点如何使用布隆过滤器

布隆过滤器用于过滤SPV节点从其对等节点接收的交易（和包含它们的区块），仅选择SPV节点感兴趣的交易，而不会泄露其感兴趣的地址或密钥。

### 8.13 交易池

#### 孤儿交易池

若一个交易的输入引用是一个未知的交易，就会被存放到孤儿交易池知道父交易到达。

## 第9章 区块链

### 9.1 简介

区块链是向后连接，每个区块都指向前一个区块，故经常被视为垂直栈。用“高度”描述区块大小

### 9.2 区块结构

block size（4 bytes）：描述区块大小

block header（80 bytes）：区块头

transaction counter（1-9 bytes）：描述交易数

transactions：交易

### 9.3 区块头

version（4 bytes）：版本

previous block hash（32 bytes）：上一区块的哈希值

merkle root（32 bytes）：默克尔树根，用于汇总所有交易的数据结构

timestamp（4 bytes）：时间戳

difficulty target（4 bytes）：难度

nonce（4 bytes）：随机数

### 9.4 区块标识符：区块头哈希值和区块高度

#### 区块头哈希值

一个区块不管是在网络上传输时，还是它作为区块链的一部分被存储在某节点的永久性存储设备上，其区块哈希值实际上都不包含在区块的数据结构里

#### 区块高度

一个区块高度并不总是标识一个唯一的区块

### 9.7 默克尔树

merkle树，用来归纳区块中所有的交易，生成整个交易集合的哈希值，且可以用于验证某交易是否存在于区块

### 9.8 默克尔树和SPV

SPV与对等节点之间建立布隆过滤器，只接受自己感兴趣地址的交易

对等节点发现满足布隆过滤器的交易时，会用merkleblock（包含交易+交易的默克尔树路径+区块头）发送区块

### 9.9 比特币测试区块链

testnet 测试比特币

segnet 隔离验证测试（在testnet3中已添加了隔离验证功能，已经不再需要）

regtest 本地区块链

## 第10章 挖矿与共识

### 10.1 简介

挖矿目的不是创造新的比特币，挖矿是一种去中心化的交易清算机制，产生新币是顺带的激励机制。

奖励机制是模拟收益递减模式->避免了通货膨胀，但是又通货紧缩风险

除了挖矿创造新的比特币，矿工还会从每笔交易中得到该区块的小费。目前这笔费用只占收入的0.5%。

### 10.3 交易独立校验

每个节点会对交易的合法性进行独立校验，具体校验规则较多

### 10.7 构建区块

工作量证明算法的难度为按二进制bit数来设定，哈希值开头多少个bit必须是0

```
New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)
```

### 10.10 区块链的组装与选择

#### 发生分叉时

即出现两条等长的链

将一条链作为候选链，直到最长链出现

### 10.13 改变共识规则

#### 硬分叉

由于共识规则的变化，网络分叉出两条链。不能向前兼容，未升级的系统不能处理新的共识规则

四个阶段：软分叉、网络分叉（旧节点只连接倒旧节点，新节点只连接到新节点）、挖矿分叉、区块链分叉

#### 软分叉

只增加约束条件，不扩展它们；不要求所有节点升级，不强制非升级节点脱离共识

## 11 比特币安全

### 11.1 安全准则

不要将用户的密钥控制权拿走，也不要让交易离开区块链

#### 做法1

将所有用户资金集中在一个包含私钥的热钱包，并存在在服务器上。

夺取了用户的掌控权，通过单一系统中心化控制密钥->黑客攻破系统，给用户带来恶果

#### 做法2

为了减少交易费或加快交易处理速度，接受链下交易。将交易记录在内部的中心化账本上，然后同步到比特币区块链中。

资金会被挪用；仅仅是复制了传统金融网络

#### 信任根

比特币应以区块链为信任根

## 第12章 区块链应用

### 12.4 染色币

#### 定义

利用比特币交易来记录比特币之外的外部资产的创建、所有权和转让的技术

### 12.5 合约币 counterparty

#### 定义

在比特币之上建立的协议层

### 12.7 闪电网络（可路由的支付通道）

#### 定义

闪电网络是一种端到端连接的双向支付通道的可路由网络。这样的网络可以允许任何参与者在不信任任何中间人的情况下将支付从一个通道路由到另一个通道。bitcoin源码解读

# 比特币开发指南

### 工作量证明

为了证明创建区块的工作量，需要创建一个不超过某个值的区块头的散列

### 交易数据

币基（coinbase）交易的为话费UTXO，需要100个块之后才能使用->防止双花攻击

如果有奇数个txids，没有合作伙伴的txid会使用自己的副本进行散列

SPV节点验证散列值时，只需要根据本身存储的merkle树根及下载的几个散列，就可验证交易的合法性

### 共识规则更改

矿工激活软分叉(MASF)：设立标记日，规则在预设时间或块高度后强制执行。软分拆等待多数哈希速率显示对新共识规则准备就绪，一旦阈值通过，所有节点开始执行新规则

## 合约

### 托管与仲裁



# 精通以太坊

## 第1章 什么是以太坊

### 功能

全局可访问的单例状态

对状态进行更改的虚拟机

### 与比特币比较

#### 共同点

连接到参与者的对等网络+用于状态同步的共识算法+数字货币（以太）+全局账本（区块链）

#### 比特币的专业描述

将比特币视为分布式共识状态机，其中交易引起全局的状态转移，从而更改比特币的所有权。状态转移受共识规则的制约，允许所有参与者在开采数个区块后再共同状态上回合。

#### 以太坊与通用计算机区别

以太坊状态变化受共识规则的支配，且状态通过共享账本全球分布

### 以太坊的组件

P2P网络、共识规则、交易、状态机、区块链、共识算法、客户端

### 以太坊与图灵完整性

以太坊的突破性创新是将存储程序计算机的通用计算架构与去中心化区块链相结合，从而创建分布式单状态（单例）世界计算机。以太坊程序“到处”运行，但却产生了共识规则所保证的共同（共识）状态。

#### 图灵完备

无法再计算机上模拟程序来预测程序是否会终止

#### gas燃气

智能合约的计算上限，超过时会被停止

### 去中心化应用DApp

智能合约+web前端用户界面

### 以太坊开发文化

提倡硬分叉

## 第2章 以太坊基础
=======
# 精通以太坊

## 第1章

EVM（Ethernet虚拟机）是一个全球性的单例，这意味着它的运作方式就好像它是一个全球性的单实例计算机

## 第2章 以太坊基础

### 单位

1.以太ether，ETH，Ξ ，♦

2.wei

3.ether=$1*10^8$wei

## 第3章 以太坊客户端

### 以太坊协议实现

Go（Geth），Rust（parity），C ++（cpp-ethereum），Python（pyethereum），Scala（mantis）和Java（harmony）

### 轻量级钱包

#### 和钱包比较

概念经常可以互换，轻量级客户端除了提供钱包的交易功能，还提供API

#### 和SPV客户端比较

SPV客户端使用Merkle验证区块链是否包含交易

以太坊轻量级客户端通常不验证区块头或交易，他们通过RPC访问区块链

## 第4章 以太坊测试网

### geth

连接到ropsten网络，使用命令行参数 --testnet即可

### parity

同步ropsten网络：parity --chain ropsten

同步kovan网络：parity --chain kovan

## 第6章 钱包

### 钱包技术

非确定性钱包：每个密钥从随机数中独立生成，密钥不相互关联

确定性钱包：所有密钥来自单个主密钥（种子seed），使用不同的密钥推导方法（树状结构）等。

典型确定性钱包：分层确定钱包（hierachical deterministic，HD）

#### 非确定性钱包

将密钥存储在_keystore_文件（一种_JSON_编码文件）

_kdf_（_Key_派生函数），也称密钥扩展算法，用于防止对密钥的暴力破解（或称字典攻击，彩虹表攻击）

​	kdfparams中，规定了盐和哈希轮数，使得攻击难度增大

#### 确定性钱包

种子+其他数据（如链码、索引编号）组合导出私钥

## 第7章 交易

### nonce随机数

#### 定义

定义1：与地址发送的交易数量相等的标量值

定义2：对于具有关联代码的用户，表示此账户创建的合约数量

#### 作用

nonce时一个连续的随机数，防止账户余额的错误计算，防止双花攻击

#### 栗子

```
web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
40
```

交易计数为40，意味着0-39的nonce已经被看到，下一个交易的nonce会是40

#### 使用

某一地址的nonce大于当前的nonce，该交易会被放到交易池的队列中，直到缺失的nonce被提交

### gas燃气

startGas：交易发起人的预算

gasPrice：每笔交易花费的gas

### 燃烧ether

交易收件人地址在_to_中指定，是一个20字节的以太坊地址

当地址没有对应的私钥或者合约时，ether被燃烧，永远不会被花费

### 交易的数据和价值

value和data字段

只有value的交易：支付

只有data的交易：调用

根据目标地址是EOA还是合约，交易行为会有很大不同

### 离线签名

传输和签名分离

根据所需的安全级别，离线签名计算机可能与在线计算机存在不同程度的分离

## 第8章 智能合约

### 定义

在以太坊虚拟机环境中确定性的运行的不可变的计算机程序，该虚拟机作为一个去中心化的世界计算机运行

### 生命周期

合约使用高级语言编写，编译后会变成EVM中运行的低级字节码

合约不会自行运行，除了在交易出发执行，直接或间接作为合约调用链的一部分时，合约在区块链中属于“休眠”

交易时原子性的，尽在交易成功终止时记录全局状态的更改；若交易失败，则所有状态变化会回滚

合约代码不可更改，但是合约可被删除；合约的交易历史不会被删除

### Solidity

#### 编译选项

solc --bin --optimize 生成合约的优化二进制文件

solc --abi 生成ABI

#### ABI

定义：应用程序二进制接口，是机器代码级别和用户运行的程序级别的两个程序模块的接口。

用处：定义合约中哪些函数可被调用，描述函数如何接受参数，如何返回数据

与API区别：基本没联系

#### 选择编译器和语言版本

在程序开头使用

```
pragma solidity ^0.4.19;
```

#### 预定义的全局变量和函数

msg 调用交易/消息上下文

```
msg是对象启动合约执行的交易（源自EOA）或消息（源自合约）
msg.sender 发起消息的地址
msg.value 与消息一起发送的以太网值
msg.gas 调用合约的消息留下的gas量。弃用，gasleft()替换
msg.data 调用合约的消息中的数据
msg.sig 函数选择器
```

tx 交易上下文

```
tx.gasprice 发起调用的交易中的gas的价格
tx.origin 源自EOA交易的完整调用堆栈
```

block 区块上下文

address 地址对象

内置函数

```
addmod mulmod
keccak256, sha256, sha3, ripemd160 哈希算法
ecrecover 从签名中恢复签署消息的地址
```

#### 合约

contract 类似于class，定义了数据和方法

interface 接口，对于函数只有声明没有定义

library 库合约，只能部署一次并被其他合约使用的合约

#### 函数

```
function FunctionName([parameters]){public|private|internal|external}[pure|constant|view|payable][modifiers][return(<return type>)]
1. FunctionName 函数名
2. paramenters 参数
3. {public|private|internal|external} 可见性修饰符
	3.1 public 默认，可被其他合约、交易、合约内部调用
	3.2 external 除非使用this作前缀，否则不能从合约中调用
	3.3 internal 只能合约内部、继承合约调用
	3.4 private 与internal类似，但不能被继承合约调用
4. [pure|constant|view|payable]影响函数行为
	4.1 constant/view 承诺不修改任何状态。constant是view的别名，将被弃用
	4.2 pure 不读写任何变量
	4.3 payable 接收付款的功能。若没有payable描述，则拒绝收款，除非来源于coinbase或作为合约终止（SELFDESTRUCT）目的地
5. modifiers 函数修改器，符合条件时才可继承

函数修改器栗子
contract owned {
    function owned() public { owner = msg.sender; }
    address owner;

    // 定义了一个函数修改器，可被继承
    //  修饰时，函数体被插入到 “_;” 处
    // 不符合条件时，将抛出异常
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
}
contract mortal is owned {
    //  使用继承的`onlyOwner` 
    function close() public onlyOwner {
        selfdestruct(owner);
    }
}
```

#### 构造和自毁函数

构造函数 constructor

自毁函数 selfdestruct(address recipient)

#### 合约继承

```
constract Child is Parent1, Parent2{}
```

#### 错误处理

assert, require 条件为假，停止执行，返回错误

revert 停止执行合约并还原任何状态更改

#### 事件

没看懂

#### 设计模式

最常见的三类问题：访问控制access control，状态流state flow，资金支出fund disbursement

访问控制：使用modifier

状态：使用枚举表示

资金支出：一般命名为withdraw函数

# what is cryptoeconomics

## Zk-Snarks

Zero-Knowledge Succinct Non-Interactive Argument of Knowledge

zero-knowledge：零知识证明

succinct：证据信息较短，方便验证

non-interactive：几乎没有交互，意味着可公开验证

arguments：计算完好，证明者无法在PPT时间内造出伪证

## 区块链的奖励惩罚机制

Tokens：区块链的积极参与者会获得货币

Privileges：区块拥有者拥有决策权，可以对交易双方进行收费

rewards：好的参与者会得到金钱奖励或者决策权

punishment：坏的参与者会被罚款或者剥夺决策权

## 加密货币的价值来源

信任

# Paper wallet guide: how to protec your cryptocurrenct

## 热存储和冷存储

热存储：将加密货币存储在设备中，该设备直接连接到网络，随时可以进行交易。

优点：快速交易；兼容大量设备；用户界面友好，简单操作；

缺点：易被黑客攻击；设备的损坏会导致钱包的损坏，导致用户损失；



冷存储：加密货币存储在完全离线的设备



## multi-signature wallets多签名钱包

类似于门限密码

## harware wallet

## paper wallet

最安全的钱包


>>>>>>> b3970b30f33ed6e1c96a5b845339d2d047cf575b

# 以太坊白皮书

## 其他的区块链应用

### 建立共识协议的两种方法

建立独立的网络->应用太小不足以保证自由区块链安全

在比特币网络上建立协议->没有继承SPV特性，需要向后扫描所有区块

## 脚本

一定程度上能实现智能合约

### 缺陷

· 缺少图灵完备性：缺失循环，不能支持所有计算

· 价值盲：不能为取款额度提供精细的控制

· 缺少状态：UTXO只有已花费或未花费的状态，意味着UTXO只能建立简单的、一次性的合约

· 区块链盲：UTXO看不到区块链的数据

## 建立高级应用的三种方法

建立一个新的区块链

在比特币区块链上使用脚本

在比特币上建立元币协议

## 以太坊优点

图灵完备，价值知晓（value-awareness），区块链知晓（blockchain-awareness），多状态

## 以太坊账户

### 组成

随机数+以太币余额+合约代码+存储（默认为空）

### 类型

外部账户：私钥控制，没有代码。

合约账户：合约代码控制。

交互过程：用户通过创建和签名一笔交易从外部账户发送消息，合约内部代码被激活，对内部存储进行读取和写入

## 消息和交易

### 消息与比特币交易区别

以太坊消息由外部实体或合约创建；比特币交易只能从外部创建

以太坊消息可以选择包含数据

若以太坊消息是合约用户，可以选择回应

### 以太坊交易

存储从外部账户发出的消息的签名数据包

包含：消息接受者、用于确认发送者的签名、以太币账户余额、要发送的数据、STARTGAS、GASPRICE

### 区块链挖矿

帕特里夏树（patricia tree）

## 应用

三类

金融应用：子货币，金融衍生品，对冲合约，储蓄钱包，遗嘱，雇佣合同

半金融应用：自我强制悬赏

非金融应用：在线投票，去中心化治理

### 令牌系统

### 金融衍生品和价值稳定的货币

主要挑战：需要参照外部的价格发布器

常见推荐方案：货币发行者背书资产，对货币有权发行和赎回。此时网络不是去中心化的。

替代方案：投机者组成去中心化市场，投机者不能讨价还价

风险：自由言论、欺诈

### 身份和信誉系统

### 去中心化存储

### 去中心化组织

DAO, decentralized autonomous organization，用密码学方案使得投票结果强制执行

## 杂项

### 改进版幽灵协议

动机：区块的高作费率，使得拥有算力更多的矿池能更有效率

解决方法：加入叔区块。以太坊中，废区块只能以叔区块的身份被父母区块的第二代至第五代纳入计算

# 以太坊开发入门指南

## 智能合约

### 定义

以太坊那个的一种特殊账户

### 以太坊账户

#### 用户账户

地址+余额

#### 智能合约账户

地址+余额+状态+代码

状态：所有变量和变量的当前状态

代码：编译后可在以太坊客户端和节点运行的字节码

### 交易

#### 价值传递

TO：收款地址

DATA：留空或留言信息

FROM：谁发出

AMOUNT：发送多少

#### 创建合约

TO：留空

DATA：包含编译为字节码的智能合约代码

FROM：谁创建

AMOUNT：可以是0或任何数量的以太，代表合约的存款

#### 调用合约函数

TO：目标合约地址

DATA：包含函数名称和参数

FROM：谁调用

AMOUNT：可以是0或任何数量的以太，代表支付合约服务费用

### 燃气gas

执行某一个操作所需的单位，代表一个事务的工作量

由于以太价格会变化，因此将计算价格与以太币价格区分开来很有必要

#### 燃料Fuel和费用Fee的区别

燃料单位是gas

费用单位是ETH

Fee = (startGas-remaining) * gasPrice

startGas是一个交易执行后，所剩燃气的最小值

#### Out of Gas Exception

费用不够执行完交易，这是以太币会无偿支付给合约地址，而合约不需要执行

#### Block gas limit（BGL）区块燃气限制

通过限制每个区块的燃气上限，限制每个区块可以包含的交易数

目前每个区块可以容纳224个交易

允许区块每次调整按1/1024倍数调整BGL大小

#### 高startgas可能导致的延迟

用户偏向于选择低startgas的合约

## 以太坊虚拟机

### 固定油费 intrinsic gas

每笔交易需要收取的固定费用

### 信息传递流程

交易transaction->消息message->合同contract->解释器->调用合约函数

### 合同contract

根据合约地址CodeAddr，从StateDB中加载代码送入解释器

### 解释器

四大组件：PC寄存器指向当前执行指令、Stack执行堆栈、Memory内存空间、Gas油耗池

### 合约调用合约

四种方式：CALL、CALLCODE、DELEGATECALL、STATICALL

#### CALL vs CALLCODE

CALL使用被调用者的存储数据，CALLCODE使用被调用者的存储数据

#### CALLCODE vs DELEGATECALL

DELEGATECALL会一直使用原始调用者的 地址，CALLCODE不会

# Solidity中文文档

## 合约结构

状态变量、函数、函数修改器、事件、结构体、枚举类型

事件是能方便调用以太坊虚拟机日志功能的接口，使用event进行声明，emit进行触发

## 类型

### 地址类型

address：20个字节的值（以太坊地址大小）

ddress payable：可支付地址，拥有成员函数transfer和send，可以接受以太币地址

ddress payble到address可以隐式转换，反过来必须显式转换

### 函数

```
function (<parameter types>) {internal|external} [pure|constant|view|payable] [returns (<return types>)]
```

### 映射

mapping(_KeyType => _ValueType)

_KeyType可以是任何基本类型，和只有包括bytes、string在内的数组类型

## 表达式和控制结构

### 函数调用

分为内部函数调用和外部函数调用

#### 内部函数调用

内部函数直接跳转实现（即递归），最多递归1024层

#### 外部函数调用

外部函数通过合约实例或者this，通过一个消息调用来实现，而不是直接跳转

构造函数不可以使用this（此时合约实例并未创建）

#### 具名调用

参数列表必须按名称与函数声明中的参数列表相符，但可按任意顺序排列

```
contract C {
    mapping(uint => uint) data;

    function f() public {
        set({value: 2, key: 3});
    }

    function set(uint key, uint value) public {
        data[key] = value;
    }

}
```

## 合约

### 创建合约

只允许有一个构造函数

### 可见性

external

public

internal

private

状态变量不能设置为external，默认是internal

在类型参数列表和返回关键字间声明

```
function f(uint a) private pure returns(uint b) {return a + 1;}
```

### Getter函数

编译器自动为所有public状态变量生成getter函数。内部调用类似于调用变量，外部调用类似于调用函数

```
contract C{
	uint public data;
	function x() public {
		data = 3; // 内部访问
		uint val = this.data(); // 外部访问
	}
}
```

### Modifiers

```
contract owned {
    function owned() public { owner = msg.sender; }
    address owner;

    // 这个合约只定义一个修改器，但并未使用： 它将会在派生合约中用到。
    // 修改器所修饰的函数体会被插入到特殊符号 _; 的位置。
    // 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。
    modifier onlyOwner {
        require(
            msg.sender == owner,
            "Only owner can call this function."
        );
        _;
    }
}

contract destructible is owned {
    // 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `destroy` 函数，
    // 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。
    function destroy() public onlyOwner {
        selfdestruct(owner);
    }
}

```

1. 修改器或函数体中显示的return语句仅仅跳出当前的修改器和函数体，对继承该修改器或函数体函数，执行逻辑会从"_"后继续执行

### Constant和Immutable

均只能赋值一次，仅支持字符串和值类型

constant使用常量赋值，Immutable限制较constant少

### 函数

可以任意数量参数作为输出，有两种方法

```
contract Simple {
    function arithmetic(uint _a, uint _b)
        public
        pure
        returns (uint o_sum, uint o_product)
    {
        o_sum = _a + _b;
        o_product = _a * _b;
    }
}
```

```
contract Simple {
    function arithmetic(uint _a, uint _b)
        public
        pure
        returns (uint o_sum, uint o_product)
    {
        return (_a + _b, _a * _b);
    }
}
```

### 事件

没看懂

### 继承

多重继承，使用is

注意点有：

1. 使用virtual描述的函数，可以被子类重写
2. 调用父类函数时，使用super
3. 多重继承的子类，重写的函数需要指定override
4. 多次定义的函数被调用时，按照给定继承的基类从右到左深度优先的方式进行搜索，第一次匹配时停止

```
pragma solidity >=0.6.0 <0.7.0;

contract Base
{
    function foo() virtual public {}
}

contract Middle is Base {}

contract Inherited is Middle
{
    function foo() public override {}
}
```

```
pragma solidity >=0.6.0 <0.7.0;

contract owned {
    constructor() public { owner = msg.sender; }
    address owner;
}

contract Destructible is owned {
    function destroy() virtual public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

contract Base1 is Destructible {
    function destroy() public virtual override { /* 清除操作 1 */ super.destroy(); }
}


contract Base2 is Destructible {
    function destroy() public  virtual override { /* 清除操作 2 */ super.destroy(); }
}

contract Final is Base1, Base2 {
    function destroy() public override(Base1, Base2) { super.destroy(); }
}
```

### 接口

1. 无法继承合约，可以继承接口
2. 所有的函数都是external
3. 无法定义构造函数
4. 无法定义状态变量

### 库

library关键字，没看懂

### using for

附加库函数，没看懂